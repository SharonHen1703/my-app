package com.myapp.server.auctions.service;

import com.myapp.server.auctions.dto.CreateAuctionRequest;
import com.myapp.server.auctions.entity.Auction;
import com.myapp.server.auctions.entity.enums.AuctionCategory;
import com.myapp.server.auctions.entity.enums.AuctionCondition;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Contains business logic and validation rules for auctions.
 * Pure business rules without dependencies on external services.
 */
@Component
public class AuctionPolicy {

    /**
     * Validates a create auction request
     */
    public void validateCreateAuctionRequest(CreateAuctionRequest request) {
        if (request.title() == null || request.title().trim().isEmpty()) {
            throw new IllegalArgumentException("Title cannot be empty");
        }
        
        if (request.minPrice() == null || request.minPrice().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Min price must be greater than 0");
        }
        
        if (request.bidIncrement() == null || request.bidIncrement().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Bid increment must be greater than 0");
        }
        
        if (request.endDate() == null || request.endDate().isBefore(LocalDateTime.now())) {
            throw new IllegalArgumentException("End date must be in the future");
        }
        
        validateCondition(request.condition());
        validateCategory(request.category());
    }
    
    /**
     * Validates condition string
     */
    public void validateCondition(String condition) {
        if (condition == null || condition.trim().isEmpty()) {
            throw new IllegalArgumentException("Condition cannot be empty");
        }
        
        try {
            AuctionCondition.fromValue(condition);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid condition: " + condition);
        }
    }
    
    /**
     * Validates and processes category string for search
     */
    public String validateCategory(String category) {
        if (category == null || category.trim().isEmpty()) {
            return null;
        }
        return category.trim();
    }
    
    /**
     * Parses category string to enum
     */
    public AuctionCategory parseCategory(String category) {
        if (category == null || category.trim().isEmpty()) {
            throw new IllegalArgumentException("Category cannot be empty");
        }
        
        try {
            return AuctionCategory.fromCode(category.trim());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid category: " + category);
        }
    }
    
    /**
     * Validates and processes conditions list
     */
    public List<String> validateAndParseConditions(List<String> conditions) {
        if (conditions == null || conditions.isEmpty()) {
            return null;
        }
        
        return conditions.stream()
            .filter(condition -> condition != null && !condition.trim().isEmpty())
            .map(String::trim)
            .collect(Collectors.toList());
    }
    
    /**
     * Validates and processes search text
     */
    public String validateSearchText(String searchText) {
        if (searchText == null || searchText.trim().isEmpty()) {
            return null;
        }
        return searchText.trim();
    }
    
    /**
     * Validates if auction can be updated
     */
    public void validateAuctionCanBeUpdated(Auction auction) {
        if (auction.getBidsCount() > 0) {
            throw new IllegalStateException("Cannot update auction with existing bids");
        }
    }
    
    /**
     * Validates if auction can be deleted
     */
    public void validateAuctionCanBeDeleted(Auction auction) {
        if (auction.getBidsCount() > 0) {
            throw new IllegalStateException("Cannot delete auction with existing bids");
        }
    }
    
    /**
     * Applies creation defaults to new auction
     */
    public void applyCreationDefaults(Auction auction) {
        // Set default values that are not in the request
        if (auction.getCurrentBidAmount() == null) {
            auction.setCurrentBidAmount(auction.getMinPrice());
        }
        if (auction.getBidsCount() == null) {
            auction.setBidsCount(0);
        }
    }
    
    /**
     * Applies update defaults to auction
     */
    public void applyUpdateDefaults(Auction auction) {
        // Add any update-specific business rules here
    }
}

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Pure business logic for auction validations and rules.
 * Contains no side effects - only pure functions for auction business rules.
 */
@Component
public class AuctionPolicy {
    
    /**
     * Validates if conditions filter is properly formatted and converts to safe list.
     */
    public List<AuctionCondition> validateAndParseConditions(List<String> conditions) {
        if (conditions == null || conditions.isEmpty()) {
            return null;
        }
        
        List<AuctionCondition> cleaned = conditions.stream()
            .filter(c -> c != null && !c.trim().isEmpty())
            .map(String::trim)
            .map(this::parseCondition)
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
            
        return cleaned.isEmpty() ? null : cleaned;
    }
    
    /**
     * Validates search text and returns safe version or null.
     */
    public String validateSearchText(String searchText) {
        if (searchText == null || searchText.trim().isEmpty()) {
            return null;
        }
        String trimmed = searchText.trim();
        return trimmed.length() > 100 ? trimmed.substring(0, 100) : trimmed;
    }
    
    /**
     * Validates category filter.
     */
    public String validateCategory(String category) {
        if (category == null || category.trim().isEmpty()) {
            return null;
        }
        return category.trim();
    }
    
    /**
     * Helper method to parse condition string to AuctionCondition enum.
     */
    private AuctionCondition parseCondition(String conditionStr) {
        if (conditionStr == null || conditionStr.trim().isEmpty()) {
            return null;
        }
        
        try {
            for (AuctionCondition condition : AuctionCondition.values()) {
                if (condition.getValue().equals(conditionStr.trim())) {
                    return condition;
                }
            }
        } catch (Exception e) {
            System.out.println("Failed to parse condition: " + conditionStr + ", error: " + e.getMessage());
        }
        
        return null;
    }
}
